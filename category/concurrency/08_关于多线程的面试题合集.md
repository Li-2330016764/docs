# 实现多线程有几种方式？
> 根据oracle的文档的描述，实现多线程只有两种方式:继承Thread类重写run方法和实现Runnable接口实现run方法，但是根据源码的实现方式，Thread类其实也实现了Runnable接口，并且Thread的类的run方法也是通过target.run()的方式进行调用，所以在本质上，也就是“继承Thread类然后重写run()”和“实现Runnable接口并传入Thread类”在实现多线程的本质上，并没有区别，都是最终调用了start()方法来新建线程。

# 一个线程两次调用start()会出现什么情况，为什么？
> 会抛出线程状态异常，IllegalThreadStateException，因为同步方法start 判断了线程状态 threadStatus是否等于0，threadStatus等于0表示该线程是NEW状态，第一次执行的时候，线程状态发生改变，threadStatus的值不为0,因此抛出异常。


# 既然start方法会调用run方法，为什么调用start方法，而不是run方法
> 因为start方法才是真正意义上的调用线程的方法，进行一系列的启动线程的方法，如设置上下文，设置寄存器的相关信息，判断线程状态，加入父线程所在的组，最后调用start0方法，启动线程，而直接调用run方法则是普通的方法调用，不会用启动线程的方法调用run方法。

# 如何停止一个线程?
> java并没有提供停止线程的方式，仅仅提供了中断线程的方式，即使用interrupt的方式，来通知线程中断。想让线程中断需要请求方，被停止方配合.
> 请求方通过调用线程的interrupt方法发出中断信号
>   * 被请求方中如果没有sleep/wait方法，则通过普通的Thread.current.isInterrupted()获取中断状态判断即可
>   * 被请求方中如果存在sleep/wait方法，需要处理InterruptedException异常，由sleep或wait响应中断信号停止
>   * 被请求方中子方法调用sleep/wait方法，可以选择优先在方法层抛出InterruptedException 或者是 收到中断信号之后再次设为中断状态
> * stop和suspend已经废弃使用，volatile的boolean的方式无法处理长时间阻塞的问题(例如生产者和消费者的问题上)。

# 如何处理不可中断的阻塞
> 对于不能响应InterruptedException的阻塞，很遗憾，并没有一个通用的解决方案。但是我们可以利用类中特定的可以响应中断的方法，比如ReentrantLock.lockInterruptibly()，比如关闭套接字使线程立即返回等方法来达到目的。